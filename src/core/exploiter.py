"""
OMEGA Active Exploitation Module
Base class for building exploit and scanner implementations.
"""

from ..utils.output import print_error, print_info, print_debug
from .dependencies import is_available
import time


class ActiveExploiter:
    """
    Base class for active exploitation and reconnaissance.
    Provides HTTP request handling with OPSEC features.
    """
    
    def __init__(self, opsec_manager=None, target_url="http://localhost", timeout=10):
        """
        Initialize active exploiter.
        
        Args:
            opsec_manager: OPSECManager instance
            target_url (str): Base URL for exploitation
            timeout (int): Request timeout in seconds
        """
        self.is_available = is_available('requests')
        if not self.is_available:
            print_error("'requests' library required for HTTP exploitation")
            return
        
        try:
            import requests
            self.requests = requests
        except ImportError:
            self.is_available = False
            return
        
        self.opsec = opsec_manager
        self.target_url = target_url
        self.timeout = timeout
        self.session = None
        self._initialize_session()
        print_debug(f"ActiveExploiter initialized for {target_url}")
    
    def _initialize_session(self):
        """Initialize requests session with OPSEC headers."""
        if not self.is_available:
            return
        
        self.session = self.requests.Session()
        self.session.verify = False
        
        if self.opsec:
            headers = self.opsec.get_opsec_headers()
            self.session.headers.update(headers)
    
    def send_request(self, method="GET", url=None, **kwargs):
        """
        Send HTTP request with OPSEC features.
        
        Args:
            method (str): HTTP method (GET, POST, etc.)
            url (str): Target URL
            **kwargs: Additional arguments for requests
        
        Returns:
            Response object or None on failure
        """
        if not self.is_available or not self.session:
            return None
        
        # Build full URL if only path provided
        if url and not url.startswith('http'):
            url = self.target_url.rstrip('/') + '/' + url.lstrip('/')
        
        # Add OPSEC headers
        headers = kwargs.get('headers', {}).copy()
        if self.opsec and self.opsec.rotate_ua:
            headers['User-Agent'] = self.opsec.get_random_ua()
        kwargs['headers'] = headers
        
        # Use rotating proxy if available
        if self.opsec and self.opsec.proxy_list:
            kwargs['proxies'] = self.opsec.get_rotating_proxy()
        elif self.opsec and self.opsec.proxy:
            kwargs['proxies'] = self.opsec.proxy
        
        try:
            start_time = time.perf_counter()
            response = self.session.request(
                method=method,
                url=url,
                timeout=self.timeout,
                **kwargs
            )
            end_time = time.perf_counter()
            
            # Add timing metadata
            response.elapsed_time_ms = (end_time - start_time) * 1000
            
            print_debug(f"{method} {url} -> {response.status_code} ({response.elapsed_time_ms:.2f}ms)")
            return response
            
        except Exception as e:
            print_error(f"Request failed: {e}")
            return None
    
    def get_request(self, url, **kwargs):
        """Send GET request."""
        return self.send_request("GET", url, **kwargs)
    
    def post_request(self, url, data=None, json=None, **kwargs):
        """Send POST request."""
        kwargs['data'] = data
        kwargs['json'] = json
        return self.send_request("POST", url, **kwargs)
    
    def put_request(self, url, data=None, json=None, **kwargs):
        """Send PUT request."""
        kwargs['data'] = data
        kwargs['json'] = json
        return self.send_request("PUT", url, **kwargs)
    
    def close(self):
        """Close the session."""
        if self.session:
            self.session.close()
